module navm.codewriter;

import std.algorithm,
			 std.traits,
			 std.meta;

import std.format : format;

import navm.common,
			 navm.error,
			 navm.meta;

/// Label Type
public struct Label{
	string name;
	alias name this;
}

/// ByteCode Writer
public struct CodeWriter(IS...) if (allSatisfy!(isCallable, IS)){
private:
	/// indices where labels occur in _code.code
	size_t[] _labOff;
	/// label names for each labOff[i]
	string[] _labOffN;
	/// generated bytecode
	Code _code;
	/// label counter
	size_t _labC;
	/// dynamic data indices in _code.code
	size_t[] _dOff;
public:

	/// pushes a numbered label
	///
	/// Returns: new label's name
	string lnPush(string prefix = null){
		string label = format!"%s%d"(prefix, _labC ++);
		lPush(label);
		return label;
	}

	/// pushes a label
	void lPush(string label){
		_code.labelNames ~= label;
		_code.labels ~= _code.code.length;
	}

	/// pushes an instruction
	void iPush(alias I, T...)(T params){
		assert(params.length == InstArgs!I.length,
				"Instruction Parameters count mismatch");
		enum S = SizeofSum!(InstArgs!I) + ushort.sizeof;
		ubyte[S] block;
		block[0 .. ushort.sizeof] =
			cast(ubyte[])(cast(ushort)staticIndexOf!(I, IS)).asBytes;
		size_t off = ushort.sizeof;
		static foreach (size_t i, Arg; T){
			static if (is (Arg == string)){
				static assert(is (InstArgs!I[i] == string));
				block[off .. off + size_t.sizeof] =
					cast(ubyte[])_code.data.length.asBytes;
				_code.data ~= params[i].length.asBytes;
				_code.data ~= cast(ubyte[])params[i];
				off += size_t.sizeof;
			} else
			static if (is (Arg == Label)){
				static assert (is (InstArgs!I[i] == size_t));
				_labOff ~= _code.code.length + off;
				_labOffN ~= params[i].name;
				off += size_t.sizeof;
			} else
			static if (isIntegral!Arg){
				static assert (isIntegral!(InstArgs!I[i]));
				static assert (is (Arg : InstArgs!I[i]));
				block[off .. off + InstArgs!I[i].sizeof] =
					cast(ubyte[])(cast(InstArgs!I[i])(params[i])).asBytes;
				off += InstArgs!I[i].sizeof;
			} else {
				static assert (is (Arg : InstArgs!I[i]));
				block[off .. off + InstArgs!I[i].sizeof] =
					cast(ubyte[])(cast(InstArgs!I[i])params[i]).asBytes;
				off += InstArgs!I[i].sizeof;
			}
		}
		_code.code ~= block;
	}

	/// commits and generates a final Code
	/// Returns: Code, or Err
	ErrVal!Code commit(){
		Code ret;
		ret.labelNames = _code.labelNames.dup;
		ret.labels = _code.labels.dup;
		ret.code = _code.code.dup;
		ret.data = _code.data.dup;

		// adjust _dOff
		foreach (size_t off; _dOff){
			ubyte[] data = ret.code[off .. off + (ubyte[]).sizeof].as!(ubyte[]);
			ret.code[off .. off + size_t.sizeof] =
				cast(ubyte[])ret.code.length.asBytes;
			ret.code[off + size_t.sizeof .. off + (2 * size_t.sizeof)] =
				cast(ubyte[])(ret.code.length + data.length).asBytes;
			ret.code ~= data;
		}

		// fix labels
		foreach (size_t i; 0 .. _labOff.length){
			ptrdiff_t labInd = ret.labelNames.countUntil(_labOffN[i]);
			if (labInd >= ret.labelNames.length || labInd < 0)
				return ErrVal!Code(Err.Type.LabelUndefined.Err(_labOffN[i]));
			ret.code[_labOff[i] .. _labOff[i] + size_t.sizeof] =
				cast(ubyte[])ret.labels[labInd].asBytes;
		}
		return ret.ErrVal!Code;
	}
}

///
unittest{
	ubyte x;
	Code code;
	void foo(int i){
		assert (i == 5);
		x |= 1;
	}
	void bar(string s){
		assert (s == "helo");
		x |= 2;
	}
	void baz(int i, float f, string s){
		assert (i == 1025);
		assert (f == 55.75);
		assert (s == "world");
		x |= 4;
	}
	void labTest(size_t l){
		ptrdiff_t ind = code.labels.countUntil(l);
		assert (ind >= 0 && ind < code.labelNames.length);
		assert (code.labelNames[ind] == "testLabel");
		x |= 8;
	}
	alias IS = AliasSeq!(foo, bar, baz, labTest);
	CodeWriter!IS writer;

	writer.lPush("main");
	writer.iPush!foo(5);
	writer.iPush!bar("helo");
	writer.iPush!baz(1025, 55.75, "world");
	writer.iPush!labTest("testLabel".Label);
	writer.lPush("testLabel");
	code = writer.commit;

	// TODO: test this output
}
